# Managed Instance Groups (MIGs) in GCP

This document explains **Managed Instance Groups (MIGs)** in **Google Cloud Platform** Compute Engine.

MIGs are one of the **most important concepts in Compute Engine** because they enable:

- High availability
- Autoscaling
- Self-healing
- Rolling updates
- Production-grade VM architectures

ðŸ‘‰ **MIGs define how many VMs exist and how they behave over time**.

---

## 1. What Is a Managed Instance Group (MIG)?

A **Managed Instance Group** is a service that:

- Creates **multiple identical VMs**
- From **one instance template**
- And manages them **automatically**

```mermaid
graph TD
    InstanceTemplate --> MIG
    MIG --> VM1
    MIG --> VM2
    MIG --> VM3
```

**Key idea:**

> You do not manage individual VMs â€” **you manage the group**.

---

## 2. Why MIGs Exist (Beginner Perspective)

Without MIGs:

- If a VM crashes â†’ app goes down
- Scaling requires manual VM creation
- Updates cause downtime
- Inconsistencies appear

With MIGs:

- Failed VMs are recreated automatically
- Traffic is spread across VMs
- Capacity grows and shrinks automatically
- Updates happen safely

```mermaid
graph TD
    Failure --> MIG
    MIG --> NewVM
```

---

## 3. Core Building Blocks of a MIG

A MIG is built from **four essential components**.

```mermaid
graph TD
    MIG --> Template[Instance Template]
    MIG --> Size[Target Size]
    MIG --> HealthCheck[Health Check]
    MIG --> Autoscaler[Autoscaler]
```

Letâ€™s understand each.

---

## 4. Instance Template (Mandatory)

A MIG **cannot exist without an instance template**.

The template defines:

- Machine type
- OS image
- Disks
- Networking
- Startup scripts
- Security settings

```mermaid
graph TD
    Template --> VM
```

**Important rule:**

> All VMs in a MIG are **identical by design**.

---

## 5. Target Size (Desired Number of VMs)

The **target size** defines:

- How many VMs should exist **at any time**

Example:

- Target size = 3
  â†’ MIG always tries to keep **3 healthy VMs running**

```mermaid
graph TD
    MIG --> Desired3[Desired = 3]
    Desired3 --> VM1
    Desired3 --> VM2
    Desired3 --> VM3
```

If one VM fails:

- MIG creates a replacement automatically

---

## 6. Health Checks (Self-Healing)

### What Is a Health Check?

A **health check** determines whether a VM is healthy.

It can check:

- HTTP response
- HTTPS response
- TCP connection

```mermaid
graph TD
    HealthCheck --> VM
    VM --> Healthy
```

---

### Why Health Checks Matter

If a VM:

- Stops responding
- Crashes
- Fails startup

The MIG:

1. Marks it unhealthy
2. Deletes it
3. Creates a new VM

```mermaid
graph TD
    UnhealthyVM --> Delete
    Delete --> NewVM
```

This is called **autohealing**.

---

## 7. Autoscaling (Dynamic Capacity)

Autoscaling allows a MIG to:

- Increase VMs when load increases
- Decrease VMs when load decreases

### Autoscaling Signals

MIGs can autoscale based on:

- CPU utilization
- Load balancer requests
- Custom metrics

```mermaid
graph TD
    Load --> Autoscaler
    Autoscaler --> MIG
    MIG --> MoreVMs
```

---

### Example: CPU-Based Autoscaling

Rule:

- Keep average CPU at ~60%

If CPU goes above:

- MIG adds more VMs

If CPU drops:

- MIG removes VMs

---

## 8. Zonal vs Regional MIGs (Very Important)

### 8.1 Zonal MIG

- All VMs in **one zone**
- Simpler
- Less resilient

```mermaid
graph TD
    ZoneA --> MIG
    MIG --> VM1
    MIG --> VM2
```

### When to use:

- Dev/Test
- Non-critical workloads

---

### 8.2 Regional MIG (Recommended for Production)

- VMs spread across **multiple zones**
- Survives zone failure
- Higher availability

```mermaid
graph TD
    Region --> ZoneA
    Region --> ZoneB
    ZoneA --> VM1
    ZoneB --> VM2
```

**Beginner rule:**

> Use **regional MIGs** for production.

---

## 9. Load Balancing with MIGs

MIGs are commonly used **behind load balancers**.

```mermaid
graph TD
    Users --> LoadBalancer
    LoadBalancer --> MIG
    MIG --> VM1
    MIG --> VM2
```

Benefits:

- Traffic distribution
- No single point of failure
- Horizontal scaling

---

## 10. Autohealing (Repairing Failed VMs)

Autohealing:

- Uses health checks
- Detects unhealthy instances
- Recreates them automatically

```mermaid
graph TD
    HealthCheck --> Unhealthy
    Unhealthy --> Autoheal
    Autoheal --> NewVM
```

**Important:**

> Autohealing replaces the VM â€” it does not â€œfixâ€ it.

---

## 11. Updating MIGs (Rolling Updates)

You **never update VMs directly** in a MIG.

Instead:

1. Create new instance template (v2)
2. Update MIG to use new template
3. Roll out changes gradually

```mermaid
graph TD
    TemplateV1 --> MIG
    TemplateV2 --> MIG
    MIG --> RollingUpdate
```

---

### Rolling Update Strategies

You can control:

- How many VMs update at once
- Whether to pause between updates
- Whether to recreate or restart VMs

This prevents downtime.

---

## 12. Stateful vs Stateless MIGs

### Stateless MIGs (Most Common)

- VMs do not store local state
- Easy to replace
- Highly scalable

**Recommended for beginners.**

---

### Stateful MIGs (Advanced)

- Preserve:
  - Disks
  - Hostnames
  - IPs

Used for:

- Stateful services
- Legacy systems

**Beginner warning:**

> Stateful MIGs are complex â€” avoid initially.

---

## 13. MIG Lifecycle (High Level)

```mermaid
graph TD
    CreateMIG --> CreateVMs
    CreateVMs --> Running
    Running --> Scale
    Running --> Heal
    Running --> Update
```

---

## 14. Example: Simple Web App MIG

### Scenario

- Web application
- Needs high availability

### Setup

- Instance template with Nginx
- Regional MIG
- Target size = 3
- HTTP health check
- Autoscaling enabled

```mermaid
graph TD
    Users --> LB
    LB --> MIG
    MIG --> VM1
    MIG --> VM2
    MIG --> VM3
```

Result:

- One VM fails â†’ auto-replaced
- Traffic spikes â†’ auto-scaled
- No downtime

---

## 15. Final Takeaway

> **Managed Instance Groups turn fragile VMs into resilient systems.**

If you use Compute Engine in production **without MIGs**, you are accepting unnecessary risk.

---
